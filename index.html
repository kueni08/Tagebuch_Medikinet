<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Medikinet Tagebuch</title>
  <link rel="manifest" href="manifest.webmanifest" />
  <link rel="icon" href="icons/icon-192.svg" type="image/svg+xml" />
  <script src="cloud-config.js" defer></script>
  <script src="js/pwa.js" defer></script>
  <style>
    :root {
      color-scheme: light;
      font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
      --bg: #f5f7fb;
      --fg: #1f2937;
      --card: #ffffff;
      --primary: #4f46e5;
      --primary-dark: #3b33c4;
      --border: #e2e7f5;
      --radius: 20px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 24px 16px 64px;
      background: var(--bg);
      color: var(--fg);
      display: flex;
      justify-content: center;
      min-height: 100vh;
    }

    .app {
      width: min(960px, 100%);
      display: grid;
      gap: 24px;
    }

    .app-nav {
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .app-nav a {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 10px 18px;
      border-radius: 999px;
      background: rgba(79, 70, 229, 0.12);
      color: var(--primary);
      text-decoration: none;
      font-weight: 600;
      font-size: 0.95rem;
      transition: background 0.2s, color 0.2s;
    }

    .app-nav a:hover,
    .app-nav a:focus-visible {
      background: rgba(79, 70, 229, 0.2);
      outline: none;
    }

    .app-nav a[aria-current="page"] {
      background: var(--primary);
      color: #ffffff;
      box-shadow: 0 12px 24px rgba(79, 70, 229, 0.25);
    }

    header {
      text-align: center;
      display: grid;
      gap: 12px;
    }

    header h1 {
      margin: 0;
      font-size: clamp(1.9rem, 2.6vw, 2.9rem);
    }

    header p {
      margin: 0;
      color: #4b5563;
      line-height: 1.5;
    }

    .card {
      background: var(--card);
      border-radius: var(--radius);
      padding: clamp(16px, 2vw, 28px);
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.08);
      display: grid;
      gap: 16px;
    }

    form {
      display: grid;
      gap: 18px;
    }

    .grid {
      display: grid;
      gap: 16px;
    }

    .grid.two {
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    label {
      display: grid;
      gap: 6px;
      font-weight: 600;
      font-size: 15px;
    }

    select,
    input[type="date"],
    textarea {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      font: inherit;
      transition: border 0.2s, box-shadow 0.2s;
      background: #fdfdff;
    }

    select:focus,
    input[type="date"]:focus,
    textarea:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.15);
    }

    textarea {
      min-height: 96px;
      resize: vertical;
    }

    .checkbox-row {
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 600;
      font-size: 15px;
    }

    .checkbox-row input {
      width: 20px;
      height: 20px;
      accent-color: var(--primary);
    }

    fieldset.checkbox-cluster {
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 14px 16px 18px;
      display: grid;
      gap: 12px;
    }

    fieldset.checkbox-cluster legend {
      font-weight: 700;
      font-size: 0.95rem;
      padding: 0 8px;
    }

    .checkbox-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 12px 18px;
    }

    .checkbox-grid .checkbox-row {
      padding: 4px 0;
    }

    .tag-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border-radius: 999px;
      padding: 4px 10px;
      background: rgba(79, 70, 229, 0.12);
      color: var(--primary);
      font-size: 0.85rem;
      font-weight: 600;
    }

    .muted {
      color: #6b7280;
    }

    .table-action {
      background: transparent;
      border: 1px solid rgba(79, 70, 229, 0.3);
      color: var(--primary);
      border-radius: 999px;
      padding: 6px 12px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .table-action:hover {
      background: rgba(79, 70, 229, 0.08);
    }

    .entry-card .table-action {
      justify-self: start;
    }

    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: flex-end;
    }

    .history-actions {
      justify-content: space-between;
      align-items: center;
    }

    .history-meta {
      flex: 1;
      min-width: 200px;
      color: #4b5563;
      font-size: 0.9rem;
      font-weight: 600;
    }

    button {
      padding: 10px 16px;
      border-radius: 999px;
      border: none;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.1s ease, box-shadow 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    button.primary {
      background: var(--primary);
      color: white;
      box-shadow: 0 10px 20px rgba(79, 70, 229, 0.25);
    }

    button.primary:hover {
      background: var(--primary-dark);
    }

    button.secondary {
      background: #e5e7ff;
      color: var(--primary);
    }

    button.ghost {
      background: transparent;
      color: var(--primary);
      padding-left: 0;
      padding-right: 0;
      box-shadow: none;
    }

    button.ghost:hover {
      text-decoration: underline;
    }

    button.danger {
      background: #fee2e2;
      color: #b91c1c;
    }

    button:active {
      transform: scale(0.98);
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: rgba(79, 70, 229, 0.12);
      color: var(--primary);
      border-radius: 999px;
      padding: 6px 12px;
      font-weight: 600;
      font-size: 0.85rem;
      width: fit-content;
    }

    .info-banner {
      display: grid;
      gap: 4px;
      font-size: 0.95rem;
      padding: 12px 16px;
      border-radius: 12px;
      border: 1px solid rgba(79, 70, 229, 0.2);
      background: rgba(79, 70, 229, 0.08);
    }

    .info-banner .info-link {
      color: var(--primary);
      text-decoration: none;
      font-weight: 600;
      margin-top: 4px;
    }

    .info-banner .info-link:hover,
    .info-banner .info-link:focus-visible {
      text-decoration: underline;
      outline: none;
    }

    .config-source {
      font-size: 0.95rem;
      color: #4b5563;
    }

    .config-form {
      display: grid;
      gap: 16px;
      margin-top: 8px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }

    .config-fields {
      display: grid;
      gap: 12px;
    }

    .config-fields.three {
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .config-form .field {
      display: grid;
      gap: 6px;
      font-weight: 600;
      font-size: 15px;
    }

    .config-form .field input {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      font: inherit;
      background: #fdfdff;
      transition: border 0.2s, box-shadow 0.2s;
    }

    .config-form .field input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.15);
    }

    .config-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }

    .config-note {
      margin: 0;
      font-size: 0.92rem;
      color: #6b7280;
      line-height: 1.5;
    }

    .config-toggle {
      display: grid;
      gap: 12px;
      margin-top: 16px;
      padding: 16px;
      border-radius: 16px;
      border: 1px dashed rgba(79, 70, 229, 0.4);
      background: rgba(79, 70, 229, 0.08);
    }

    .config-toggle p {
      margin: 0;
      color: #4b5563;
      font-size: 0.95rem;
    }

    #cloud-config-wrapper[hidden] {
      display: none;
    }

    .status {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px 16px;
      border-radius: 12px;
      font-weight: 600;
      line-height: 1.4;
    }

    .status[data-tone="info"] {
      background: #eef2ff;
      color: #3730a3;
    }

    .status[data-tone="success"] {
      background: #ecfdf5;
      color: #047857;
    }

    .status[data-tone="error"] {
      background: #fef2f2;
      color: #b91c1c;
    }

    .status[data-tone="warning"] {
      background: #fffbeb;
      color: #92400e;
    }

    .table-wrapper {
      border-radius: 16px;
      overflow-x: auto;
      background: rgba(79, 70, 229, 0.03);
      padding: 2px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.95rem;
      min-width: 720px;
    }

    th,
    td {
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      text-align: left;
    }

    th {
      background: #eef1ff;
      font-weight: 700;
    }

    tbody tr:hover {
      background: rgba(79, 70, 229, 0.05);
    }

    .empty-state {
      text-align: center;
      padding: 28px 16px;
      color: #6b7280;
      font-weight: 600;
    }

    .entries-list {
      display: none;
      gap: 12px;
    }

    .entry-card {
      border: 1px solid rgba(79, 70, 229, 0.12);
      border-radius: 16px;
      padding: 16px;
      background: white;
      display: grid;
      gap: 12px;
      box-shadow: 0 12px 24px rgba(15, 23, 42, 0.06);
    }

    .entry-card__header {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      gap: 8px;
      font-weight: 700;
    }

    .entry-card__mood {
      color: var(--primary);
    }

    .entry-card dl {
      display: grid;
      gap: 8px;
      margin: 0;
    }

    .entry-card dl div {
      display: grid;
      gap: 4px;
    }

    .entry-card dt {
      font-weight: 600;
      color: #4b5563;
      font-size: 0.9rem;
    }

    .entry-card dd {
      margin: 0;
      font-size: 0.95rem;
      line-height: 1.4;
    }

    @media (max-width: 900px) {
      body {
        padding: 20px 14px 48px;
      }
    }

    @media (max-width: 720px) {
      .app-nav {
        justify-content: center;
      }

      .app-nav a {
        flex: 1 1 100%;
      }

      .grid.two {
        grid-template-columns: 1fr;
      }

      .actions {
        justify-content: center;
      }

      .actions button {
        flex: 1 1 200px;
        justify-content: center;
      }

      .table-wrapper {
        display: none;
      }

      .entries-list {
        display: grid;
      }

      .history-meta {
        text-align: center;
      }
    }

    @media (max-width: 600px) {
      body {
        padding: 16px 12px 40px;
      }

      header p {
        font-size: 0.95rem;
      }
    }

    @media (max-width: 480px) {
      .app-nav a {
        flex-basis: 100%;
      }

      header h1 {
        font-size: 1.75rem;
      }

      .card {
        padding: 18px 16px;
      }

      button {
        width: 100%;
        justify-content: center;
      }

      .actions {
        gap: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <nav class="app-nav" aria-label="Hauptnavigation">
      <a href="index.html" aria-current="page">Tagebuch</a>
      <a href="stimmungsverlauf.html">Verlauf</a>
      <a href="cloud-guide.html">Cloud-Anleitung</a>
    </nav>
    <header>
      <h1>‚òÅÔ∏è Medikinet-Tagebuch</h1>
      <p>Speichert deine Eintr√§ge bevorzugt in einem JSONBin und legt automatisch eine lokale Sicherung an.</p>
      <p class="muted">Ohne Zugangsdaten arbeitet das Tagebuch vollst√§ndig offline.</p>
    </header>

    <section class="card" aria-labelledby="cloud-info">
      <div class="badge" id="cloud-info">Cloud-Speicher</div>
      <div class="info-banner">
        <strong>Schnellstart</strong>
        <span>Trage deine JSONBin-Zugangsdaten unten ein ‚Äì sie bleiben ausschlie√ülich lokal im Browser gespeichert.</span>
        <span>F√§llt die Cloud aus, arbeitet das Tagebuch automatisch mit der lokalen Sicherung weiter.</span>
        <a class="info-link" href="cloud-guide.html">Ausf√ºhrliche Cloud-Anleitung √∂ffnen</a>
      </div>
      <div class="config-source" id="config-source-info"></div>
      <div class="config-toggle" id="cloud-config-toggle" hidden>
        <p id="cloud-config-toggle-summary">
          Deine JSONBin-Zugangsdaten sind gespeichert. Du kannst sie bei Bedarf √ºber den Button erneut einblenden.
        </p>
        <button type="button" class="secondary" id="cloud-config-reveal-btn">Cloud-Zugangsdaten anzeigen</button>
      </div>
      <div id="cloud-config-wrapper">
        <form class="config-form" id="cloud-config-form" autocomplete="off">
          <div class="config-fields three">
            <label class="field" for="config-bin-id">
              JSONBin ID
              <input
                type="text"
                id="config-bin-id"
                name="config-bin-id"
                inputmode="text"
                spellcheck="false"
                autocomplete="off"
                placeholder="z.‚ÄØB. 64f3a6e1baf603‚Ä¶"
                required
              />
            </label>
            <label class="field" for="config-master-key">
              Master Key
              <input
                type="password"
                id="config-master-key"
                name="config-master-key"
                autocomplete="off"
                placeholder="beginnt meist mit $2b$‚Ä¶"
                required
              />
            </label>
            <label class="field" for="config-access-key">
              Access Key (optional)
              <input
                type="password"
                id="config-access-key"
                name="config-access-key"
                autocomplete="off"
                placeholder="nur falls vergeben"
              />
            </label>
          </div>
          <div class="config-actions">
            <button type="submit" class="primary">Zugangsdaten speichern</button>
            <button type="button" class="secondary" id="config-clear-btn">Gespeicherte Daten l√∂schen</button>
            <button type="button" class="ghost" id="config-hide-btn" hidden>Fenster ausblenden</button>
          </div>
          <p class="config-note" id="config-storage-note">Hinweis: Die Zugangsdaten werden ausschlie√ülich lokal im Browser gespeichert.</p>
        </form>
      </div>
      <div class="status" id="cloud-status" role="status" aria-live="polite" data-tone="info">Bitte Zugangsdaten eintragen.</div>
    </section>

    <section class="card" aria-labelledby="tagebuch-form">
      <div class="badge" id="tagebuch-form">Heutiger Eintrag</div>
      <form id="entry-form">
        <div class="grid two">
          <label>
            Datum
            <input type="date" id="datum" name="datum" required />
          </label>
          <label>
            Stimmung
            <select id="stimmung" name="stimmung" required>
              <option value="üòä Sehr gut">üòä Sehr gut</option>
              <option value="üôÇ Gut">üôÇ Gut</option>
              <option value="üòê Neutral">üòê Neutral</option>
              <option value="‚òπÔ∏è Schwankend">‚òπÔ∏è Schwankend</option>
              <option value="üò£ Herausfordernd">üò£ Herausfordernd</option>
            </select>
          </label>
          <label>
            Konzentration (Schule)
            <select id="konz" name="konz" required>
              <option value="üòä Sehr fokussiert">üòä Sehr fokussiert</option>
              <option value="üôÇ Gut fokussiert">üôÇ Gut fokussiert</option>
              <option value="üòê Mittel">üòê Mittel</option>
              <option value="‚òπÔ∏è Schwierig">‚òπÔ∏è Schwierig</option>
              <option value="üò£ Kaum m√∂glich">üò£ Kaum m√∂glich</option>
            </select>
          </label>
          <label>
            √úberreizung (Vormittag)
            <select id="vorm" name="vorm" required>
              <option value="üòä Sehr ruhig">üòä Sehr ruhig</option>
              <option value="üôÇ Gut reguliert">üôÇ Gut reguliert</option>
              <option value="üòê Leicht angespannt">üòê Leicht angespannt</option>
              <option value="‚òπÔ∏è Deutlich angespannt">‚òπÔ∏è Deutlich angespannt</option>
              <option value="üò£ Stark √ºberreizt">üò£ Stark √ºberreizt</option>
            </select>
          </label>
          <label>
            √úberreizung (Abend)
            <select id="abend" name="abend" required>
              <option value="üòä Sehr ruhig">üòä Sehr ruhig</option>
              <option value="üôÇ Gut reguliert">üôÇ Gut reguliert</option>
              <option value="üòê Leicht angespannt">üòê Leicht angespannt</option>
              <option value="‚òπÔ∏è Deutlich angespannt">‚òπÔ∏è Deutlich angespannt</option>
              <option value="üò£ Stark √ºberreizt">üò£ Stark √ºberreizt</option>
            </select>
          </label>
          <label>
            Appetit
            <select id="appetit" name="appetit" required>
              <option value="üê≠ Kaum Hunger">üê≠ Kaum Hunger</option>
              <option value="üê∞ Wenig Hunger">üê∞ Wenig Hunger</option>
              <option value="üê± Normaler Hunger">üê± Normaler Hunger</option>
              <option value="ü¶ä Gro√üer Hunger">ü¶ä Gro√üer Hunger</option>
              <option value="üêª B√§renhunger">üêª B√§renhunger</option>
            </select>
          </label>
        </div>

        <fieldset class="checkbox-cluster">
          <legend>Besondere Beobachtungen heute</legend>
          <div class="checkbox-grid">
            <label class="checkbox-row" for="ausbr">
              <input type="checkbox" id="ausbr" name="ausbr" />
              Auff√§llige Ausbr√ºche
            </label>
            <label class="checkbox-row" for="kopfweh">
              <input type="checkbox" id="kopfweh" name="kopfweh" />
              Kopfweh
            </label>
            <label class="checkbox-row" for="bauchweh">
              <input type="checkbox" id="bauchweh" name="bauchweh" />
              Bauchweh
            </label>
            <label class="checkbox-row" for="schwindel">
              <input type="checkbox" id="schwindel" name="schwindel" />
              Schwindel
            </label>
          </div>
        </fieldset>

        <label>
          Auff√§lligkeiten &amp; Notizen
          <textarea id="auff" name="auff" placeholder="z. B. Kopfweh, Bauchweh, Einschlafschwierigkeiten..."></textarea>
        </label>

        <div class="actions">
          <button type="button" class="secondary" id="reset-btn">Formular leeren</button>
          <button type="submit" class="primary">‚òÅÔ∏è Eintrag speichern</button>
        </div>
      </form>
    </section>

    <section class="card" aria-labelledby="history-title">
      <div class="badge" id="history-title">Verlauf</div>
      <div class="actions history-actions">
        <span class="history-meta" id="history-meta" aria-live="polite"></span>
        <button type="button" class="secondary" id="export-btn">üìÅ Verlauf als CSV</button>
      </div>
      <div class="table-wrapper" aria-hidden="false">
        <table aria-live="polite" aria-describedby="history-title">
          <thead>
            <tr>
              <th>Datum</th>
              <th>Stimmung</th>
              <th>Konzentration</th>
              <th>√úberreizung (VM)</th>
              <th>√úberreizung (Ab)</th>
              <th>Appetit</th>
              <th>Ausbr√ºche</th>
              <th>Nebenwirkungen</th>
              <th>Notizen</th>
              <th>Aktion</th>
            </tr>
          </thead>
          <tbody id="entries-body"></tbody>
        </table>
      </div>
      <div class="entries-list" id="entries-list" role="list" aria-live="polite" aria-hidden="true"></div>
    </section>
  </div>

    <script type="module">
    const API_BASE = "https://api.jsonbin.io/v3/b";

    const form = document.getElementById("entry-form");
    const entriesBody = document.getElementById("entries-body");
    const entriesList = document.getElementById("entries-list");
    const historyMeta = document.getElementById("history-meta");
    const resetBtn = document.getElementById("reset-btn");
    const exportBtn = document.getElementById("export-btn");
    const cloudStatus = document.getElementById("cloud-status");
    const tableWrapper = document.querySelector(".table-wrapper");
    const configForm = document.getElementById("cloud-config-form");
    const configSourceInfo = document.getElementById("config-source-info");
    const configClearBtn = document.getElementById("config-clear-btn");
    const configStorageNote = document.getElementById("config-storage-note");
    const configFormWrapper = document.getElementById("cloud-config-wrapper");
    const configToggle = document.getElementById("cloud-config-toggle");
    const configToggleSummary = document.getElementById("cloud-config-toggle-summary");
    const configRevealBtn = document.getElementById("cloud-config-reveal-btn");
    const configHideBtn = document.getElementById("config-hide-btn");
    const configInputs = {
      binId: document.getElementById("config-bin-id"),
      masterKey: document.getElementById("config-master-key"),
      accessKey: document.getElementById("config-access-key"),
    };

    const fields = [
      "datum",
      "stimmung",
      "konz",
      "vorm",
      "abend",
      "appetit",
      "ausbr",
      "kopfweh",
      "bauchweh",
      "schwindel",
      "auff",
    ];

    const booleanFields = new Set(["ausbr", "kopfweh", "bauchweh", "schwindel"]);

    const today = new Date();
    const STORAGE_KEYS = {
      config: "medikinetJsonBinConfig",
      entries: "medikinetDiaryEntries",
    };

    const mobileQuery = window.matchMedia("(max-width: 720px)");

    let cachedEntries = [];
    let eventsBound = false;
    let storageMode = "local";
    let lastSyncedAt = null;
    let lastLocalSaveAt = null;
    let configOrigin = null;

    const storageAvailable = detectStorageSupport();

    const externalConfig = normalizeConfig(
      typeof window !== "undefined" && "MEDIKINET_CLOUD_CONFIG" in window
        ? window.MEDIKINET_CLOUD_CONFIG
        : undefined
    );

    let config = externalConfig || null;
    if (config) {
      configOrigin = "external";
      storageMode = "cloud";
    }

    if (!config && storageAvailable) {
      const stored = readStoredConfig();
      if (stored) {
        config = stored;
        configOrigin = "browser";
        storageMode = "cloud";
      }
    }

    function formatDateInput(date) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, "0");
      const day = String(date.getDate()).padStart(2, "0");
      return `${year}-${month}-${day}`;
    }

    function setDefaultDate() {
      const dateInput = document.getElementById("datum");
      if (!dateInput.value) {
        dateInput.value = formatDateInput(today);
      }
    }

    function detectStorageSupport() {
      if (typeof window === "undefined" || !("localStorage" in window)) {
        return false;
      }
      try {
        const testKey = "__medikinet_config_test__";
        localStorage.setItem(testKey, "1");
        localStorage.removeItem(testKey);
        return true;
      } catch (error) {
        console.warn("Lokaler Speicher nicht verf√ºgbar", error);
        return false;
      }
    }

    function normalizeConfig(value) {
      if (!value) return null;
      const binId = typeof value.binId === "string" ? value.binId.trim() : "";
      const masterKey = typeof value.masterKey === "string" ? value.masterKey.trim() : "";
      const accessKey = typeof value.accessKey === "string" ? value.accessKey.trim() : "";
      if (!binId || !masterKey) {
        return null;
      }
      const result = { binId, masterKey };
      if (accessKey) {
        result.accessKey = accessKey;
      }
      return result;
    }

    function readStoredConfig() {
      if (!storageAvailable) return null;
      try {
        const raw = localStorage.getItem(STORAGE_KEYS.config);
        if (!raw) return null;
        return normalizeConfig(JSON.parse(raw));
      } catch (error) {
        console.warn("Gespeicherte Cloud-Konfiguration konnte nicht gelesen werden", error);
        return null;
      }
    }

    function writeStoredConfig(value) {
      if (!storageAvailable) return;
      try {
        localStorage.setItem(STORAGE_KEYS.config, JSON.stringify(value));
      } catch (error) {
        console.warn("Cloud-Konfiguration konnte nicht gespeichert werden", error);
      }
    }

    function clearStoredConfig() {
      if (!storageAvailable) return;
      try {
        localStorage.removeItem(STORAGE_KEYS.config);
      } catch (error) {
        console.warn("Cloud-Konfiguration konnte nicht entfernt werden", error);
      }
    }

    function readLocalEntries() {
      if (!storageAvailable) {
        return cachedEntries.map(normalizeEntry);
      }
      try {
        const raw = localStorage.getItem(STORAGE_KEYS.entries);
        if (!raw) {
          lastLocalSaveAt = null;
          return [];
        }
        const payload = JSON.parse(raw);
        if (Array.isArray(payload)) {
          lastLocalSaveAt = null;
          return payload.map(normalizeEntry).sort(sortByDate);
        }
        if (payload && Array.isArray(payload.entries)) {
          lastLocalSaveAt = payload.updatedAt || null;
          return payload.entries.map(normalizeEntry).sort(sortByDate);
        }
      } catch (error) {
        console.warn("Lokale Eintr√§ge konnten nicht gelesen werden", error);
      }
      return [];
    }

    function writeLocalEntries(entries) {
      if (!storageAvailable) {
        cachedEntries = entries.map(normalizeEntry);
        lastLocalSaveAt = new Date().toISOString();
        return;
      }
      try {
        const payload = {
          entries,
          updatedAt: new Date().toISOString(),
        };
        localStorage.setItem(STORAGE_KEYS.entries, JSON.stringify(payload));
        lastLocalSaveAt = payload.updatedAt;
      } catch (error) {
        console.warn("Lokale Sicherung konnte nicht gespeichert werden", error);
      }
    }

    function setStatus(message, tone = "info") {
      if (!cloudStatus) return;
      cloudStatus.textContent = message;
      cloudStatus.setAttribute("data-tone", tone);
    }

    function updateConfigSource(message) {
      if (!configSourceInfo) return;
      configSourceInfo.textContent = message;
    }

    function setConfigFormVisibility(visible) {
      if (configFormWrapper) {
        configFormWrapper.hidden = !visible;
      }
      if (configToggle) {
        configToggle.hidden = visible;
      }
    }

    function updateConfigToggleSummary(message) {
      if (!configToggleSummary) return;
      configToggleSummary.textContent = message;
    }

    function getConfigToggleMessage() {
      if (configOrigin === "browser") {
        return "Zugangsdaten sind lokal gespeichert. Du kannst sie bei Bedarf einblenden.";
      }
      if (configOrigin === "external") {
        return "Zugangsdaten stammen aus cloud-config.js. Du kannst sie bei Bedarf √ºberschreiben.";
      }
      return "Trage deine JSONBin-Zugangsdaten ein, um die Cloud-Synchronisation zu aktivieren.";
    }

    function updateConfigHideAvailability() {
      const canHide = configOrigin === "browser" || configOrigin === "external";
      if (configHideBtn) {
        configHideBtn.hidden = !canHide;
      }
      if (!canHide) {
        setConfigFormVisibility(true);
      }
      updateConfigToggleSummary(getConfigToggleMessage());
    }

    function hideConfigFormIfAllowed(message) {
      const canHide = configOrigin === "browser" || configOrigin === "external";
      if (!canHide) return;
      updateConfigToggleSummary(message || getConfigToggleMessage());
      setConfigFormVisibility(false);
    }

    function fillConfigForm(value) {
      if (!configForm) return;
      configInputs.binId.value = value?.binId || "";
      configInputs.masterKey.value = value?.masterKey || "";
      configInputs.accessKey.value = value?.accessKey || "";
    }

    function applyConfig(next, { persist = false } = {}) {
      const normalized = normalizeConfig(next);
      if (!normalized) {
        return false;
      }
      config = normalized;
      cachedEntries = [];
      storageMode = "cloud";
      lastSyncedAt = null;
      if (persist) {
        writeStoredConfig(normalized);
        configOrigin = "browser";
      } else {
        configOrigin = "inline";
      }
      return true;
    }

    function bindDiaryEvents() {
      if (eventsBound) return;
      form.addEventListener("submit", handleSubmit);
      resetBtn.addEventListener("click", handleReset);
      exportBtn.addEventListener("click", exportCsv);
      entriesBody.addEventListener("click", handleEntryAction);
      if (entriesList) {
        entriesList.addEventListener("click", handleEntryAction);
      }
      eventsBound = true;
    }

    function toggleFormDisabled(disabled) {
      const controls = form?.querySelectorAll("input, select, textarea, button");
      controls?.forEach((control) => {
        control.disabled = disabled;
      });
    }

    function syncHistoryView() {
      const hideTable = mobileQuery.matches;
      if (tableWrapper) {
        tableWrapper.setAttribute("aria-hidden", hideTable ? "true" : "false");
      }
      if (entriesList) {
        entriesList.setAttribute("aria-hidden", hideTable ? "false" : "true");
      }
    }

    if (mobileQuery.addEventListener) {
      mobileQuery.addEventListener("change", syncHistoryView);
    } else if (mobileQuery.addListener) {
      mobileQuery.addListener(syncHistoryView);
    }

    function collectSideEffects(entry) {
      return [
        entry.kopfweh ? "Kopfweh" : null,
        entry.bauchweh ? "Bauchweh" : null,
        entry.schwindel ? "Schwindel" : null,
      ].filter(Boolean);
    }

    function formatSideEffectsText(entry) {
      const list = collectSideEffects(entry);
      return list.length ? list.join(", ") : "Keine";
    }

    function createSideEffectsTags(entry) {
      const list = collectSideEffects(entry);
      if (!list.length) {
        return '<span class="muted">Keine</span>';
      }
      return `<div class="tag-list">${list
        .map((label) => `<span class="tag">${label}</span>`)
        .join("")}</div>`;
    }

    function ensureConfigAvailable() {
      if (!config) {
        throw new Error("Cloud-Konfiguration fehlt.");
      }
    }

    function normalizeEntry(entry) {
      return {
        datum: entry.datum ?? "",
        stimmung: entry.stimmung ?? "",
        konz: entry.konz ?? "",
        vorm: entry.vorm ?? "",
        abend: entry.abend ?? "",
        appetit: entry.appetit ?? "",
        ausbr: Boolean(entry.ausbr),
        kopfweh: Boolean(entry.kopfweh),
        bauchweh: Boolean(entry.bauchweh),
        schwindel: Boolean(entry.schwindel),
        auff: entry.auff ? entry.auff.toString() : "",
      };
    }

    function sortByDate(a, b) {
      if (!a?.datum) return -1;
      if (!b?.datum) return 1;
      return a.datum.localeCompare(b.datum);
    }

    function formatTimestamp(isoString) {
      if (!isoString) return null;
      const date = new Date(isoString);
      if (Number.isNaN(date.getTime())) return null;
      return date.toLocaleString("de-DE", {
        dateStyle: "short",
        timeStyle: "short",
      });
    }

    function getLastUpdateTimestamp() {
      if (storageMode === "cloud") {
        return lastSyncedAt;
      }
      if (storageMode === "local") {
        return lastLocalSaveAt;
      }
      return null;
    }

    function buildHistorySummary(entries) {
      if (!entries.length) {
        return "Noch keine Eintr√§ge";
      }
      const first = entries[0]?.datum;
      const last = entries[entries.length - 1]?.datum;
      const range =
        first && last ? (first === last ? first : `${first} bis ${last}`) : "";
      const timestamp = formatTimestamp(getLastUpdateTimestamp());
      const base = range ? `${entries.length} Eintr√§ge (${range})` : `${entries.length} Eintr√§ge`;
      return timestamp ? `${base} ¬∑ Stand ${timestamp}` : base;
    }

    function buildStatusSummary(entries) {
      if (storageMode === "cloud") {
        return entries.length
          ? `Cloud synchronisiert ‚Äì ${buildHistorySummary(entries)}`
          : "Cloud verbunden. Noch keine Eintr√§ge gespeichert.";
      }
      if (storageMode === "local") {
        return entries.length
          ? `Lokale Sicherung aktiv ‚Äì ${buildHistorySummary(entries)}`
          : "Lokale Sicherung aktiv. Noch keine Eintr√§ge.";
      }
      return entries.length
        ? `Tempor√§re Speicherung aktiv ‚Äì ${entries.length} Eintr√§ge`
        : "Tempor√§re Speicherung aktiv. Noch keine Eintr√§ge.";
    }

    function updateHistoryMeta(entries) {
      if (!historyMeta) return;
      let prefix = "Tempor√§r";
      if (storageMode === "cloud") {
        prefix = "Cloud";
      } else if (storageMode === "local") {
        prefix = "Lokal";
      }
      historyMeta.textContent = `${prefix}: ${buildHistorySummary(entries)}`;
    }

    function renderToDom(entries) {
      entriesBody.innerHTML = "";
      if (entriesList) {
        entriesList.innerHTML = "";
      }

      if (!entries.length) {
        entriesBody.innerHTML = `<tr class="empty-state"><td colspan="10">Noch keine Eintr√§ge gespeichert.</td></tr>`;
        if (entriesList) {
          entriesList.innerHTML = `<p class="empty-state" role="status">Noch keine Eintr√§ge gespeichert.</p>`;
        }
        updateHistoryMeta(entries);
        return;
      }

      for (const entry of entries) {
        const notesHtml = entry.auff ? entry.auff.replace(/\r?\n/g, "<br>") : "";
        const row = document.createElement("tr");
        row.innerHTML = `
          <td>${entry.datum}</td>
          <td>${entry.stimmung}</td>
          <td>${entry.konz}</td>
          <td>${entry.vorm}</td>
          <td>${entry.abend}</td>
          <td>${entry.appetit || ""}</td>
          <td>${entry.ausbr ? "‚úÖ Ja" : "‚ûñ Nein"}</td>
          <td>${formatSideEffectsText(entry)}</td>
          <td>${notesHtml}</td>
          <td><button type="button" class="table-action" data-entry-date="${entry.datum}" data-action="delete-entry">L√∂schen</button></td>
        `;
        entriesBody.appendChild(row);

        if (entriesList) {
          const card = document.createElement("article");
          card.className = "entry-card";
          card.setAttribute("role", "listitem");
          const notes = entry.auff ? entry.auff.replace(/\r?\n/g, "<br>") : "Keine Notizen";
          card.innerHTML = `
            <div class="entry-card__header">
              <span class="entry-card__date">${entry.datum}</span>
              <span class="entry-card__mood">${entry.stimmung}</span>
            </div>
            <dl>
              <div>
                <dt>Konzentration</dt>
                <dd>${entry.konz}</dd>
              </div>
              <div>
                <dt>√úberreizung (Vormittag)</dt>
                <dd>${entry.vorm}</dd>
              </div>
              <div>
                <dt>√úberreizung (Abend)</dt>
                <dd>${entry.abend}</dd>
              </div>
              <div>
                <dt>Appetit</dt>
                <dd>${entry.appetit || "Keine Angabe"}</dd>
              </div>
              <div>
                <dt>Ausbr√ºche</dt>
                <dd>${entry.ausbr ? "‚úÖ Ja" : "‚ûñ Nein"}</dd>
              </div>
              <div>
                <dt>Nebenwirkungen</dt>
                <dd>${createSideEffectsTags(entry)}</dd>
              </div>
              <div>
                <dt>Notizen</dt>
                <dd>${notes}</dd>
              </div>
            </dl>
            <button type="button" class="table-action" data-entry-date="${entry.datum}" data-action="delete-entry">Eintrag l√∂schen</button>
          `;
          entriesList.appendChild(card);
        }
      }

      updateHistoryMeta(entries);
    }

    function buildHeaders(includeContentType = false) {
      const headers = {};
      if (!config) {
        if (includeContentType) {
          headers["Content-Type"] = "application/json";
        }
        return headers;
      }
      if (config.masterKey) {
        headers["X-Master-Key"] = config.masterKey;
      }
      if (config.accessKey) {
        headers["X-Access-Key"] = config.accessKey;
      }
      if (includeContentType) {
        headers["Content-Type"] = "application/json";
      }
      return headers;
    }

    async function fetchFromJsonBin() {
      ensureConfigAvailable();
      const url = `${API_BASE}/${config.binId}/latest`;
      const response = await fetch(url, { headers: buildHeaders() });
      if (response.status === 404) {
        throw new Error("Bin nicht gefunden (404). Bitte √ºberpr√ºfe deine JSONBin-ID.");
      }
      if (!response.ok) {
        const message = await response.text();
        throw new Error(message || `HTTP ${response.status}`);
      }
      const payload = await response.json();
      lastSyncedAt =
        payload.metadata?.updatedAt ||
        payload.metadata?.modifiedAt ||
        payload.metadata?.createdAt ||
        new Date().toISOString();
      const entries = Array.isArray(payload.record?.entries) ? payload.record.entries : [];
      return entries.map(normalizeEntry).sort(sortByDate);
    }

    async function pushToJsonBin(entries) {
      ensureConfigAvailable();
      const url = `${API_BASE}/${config.binId}`;
      const response = await fetch(url, {
        method: "PUT",
        headers: {
          ...buildHeaders(true),
          "X-Bin-Versioning": "false",
        },
        body: JSON.stringify({
          entries,
          updatedAt: new Date().toISOString(),
        }),
      });
      if (!response.ok) {
        const message = await response.text();
        throw new Error(message || `HTTP ${response.status}`);
      }
      const payload = await response.json();
      lastSyncedAt =
        payload.metadata?.updatedAt ||
        payload.metadata?.modifiedAt ||
        payload.metadata?.createdAt ||
        new Date().toISOString();
      const savedEntries = Array.isArray(payload.record?.entries) ? payload.record.entries : entries;
      return savedEntries.map(normalizeEntry).sort(sortByDate);
    }

    async function loadEntriesFromPreferredSource({ showStatus = true } = {}) {
      if (!config) {
        const entries = readLocalEntries();
        cachedEntries = entries;
        renderToDom(entries);
        const message = storageAvailable
          ? "Keine JSONBin-Zugangsdaten hinterlegt. Eintr√§ge werden lokal gespeichert."
          : "Keine JSONBin-Zugangsdaten hinterlegt. Speichern ist nur tempor√§r m√∂glich.";
        setStatus(message, storageAvailable ? "warning" : "error");
        storageMode = storageAvailable ? "local" : "memory";
        return entries;
      }

      if (showStatus) {
        setStatus("Synchronisiere mit JSONBin‚Ä¶", "info");
      }

      try {
        const entries = await fetchFromJsonBin();
        storageMode = "cloud";
        cachedEntries = entries;
        writeLocalEntries(entries);
        renderToDom(entries);
        if (showStatus) {
          setStatus(buildStatusSummary(entries), "success");
        }
        return entries;
      } catch (error) {
        console.error("Fehler beim Laden", error);
        storageMode = storageAvailable ? "local" : "memory";
        const entries = readLocalEntries();
        cachedEntries = entries;
        renderToDom(entries);
        const message = storageAvailable
          ? `Cloud nicht erreichbar (${error.message}). Lokale Sicherung aktiv.`
          : `Cloud nicht erreichbar (${error.message}). Zwischenspeicherung ‚Äì Daten gehen beim Schlie√üen verloren.`;
        if (showStatus) {
          setStatus(message, storageAvailable ? "warning" : "error");
        }
        return entries;
      }
    }

    async function getEntriesForWrite() {
      if (!config) {
        storageMode = storageAvailable ? "local" : "memory";
        return readLocalEntries();
      }
      try {
        const latest = await fetchFromJsonBin();
        storageMode = "cloud";
        writeLocalEntries(latest);
        return latest;
      } catch (error) {
        console.error("Fehler beim Abrufen", error);
        storageMode = storageAvailable ? "local" : "memory";
        const entries = readLocalEntries();
        const message = storageAvailable
          ? `Cloud nicht erreichbar (${error.message}). √Ñnderungen werden lokal gespeichert.`
          : `Cloud nicht erreichbar (${error.message}). √Ñnderungen k√∂nnen nur tempor√§r gespeichert werden.`;
        setStatus(message, storageAvailable ? "warning" : "error");
        return entries;
      }
    }

    async function persistEntries(entries) {
      if (!config) {
        storageMode = storageAvailable ? "local" : "memory";
        writeLocalEntries(entries);
        cachedEntries = entries;
        renderToDom(entries);
        const tone = storageAvailable ? "warning" : "error";
        setStatus(buildStatusSummary(entries), tone);
        return entries;
      }
      try {
        const saved = await pushToJsonBin(entries);
        storageMode = "cloud";
        writeLocalEntries(saved);
        cachedEntries = saved;
        renderToDom(saved);
        setStatus(buildStatusSummary(saved), "success");
        return saved;
      } catch (error) {
        console.error("Fehler beim Speichern", error);
        storageMode = storageAvailable ? "local" : "memory";
        writeLocalEntries(entries);
        cachedEntries = entries;
        renderToDom(entries);
        const message = storageAvailable
          ? `Cloud-Speicherung fehlgeschlagen (${error.message}). Eintrag wurde lokal gesichert.`
          : `Cloud-Speicherung fehlgeschlagen (${error.message}). Eintrag konnte nur tempor√§r gesichert werden.`;
        setStatus(message, storageAvailable ? "warning" : "error");
        return entries;
      }
    }

    async function handleSubmit(event) {
      event.preventDefault();
      const formData = new FormData(form);
      const entry = {};

      for (const field of fields) {
        if (booleanFields.has(field)) {
          entry[field] = formData.get(field) === "on";
        } else {
          entry[field] = (formData.get(field) || "").toString().trim();
        }
      }

      toggleFormDisabled(true);
      const savingToCloud = config && storageMode === "cloud";
      const tone = savingToCloud ? "info" : storageAvailable ? "warning" : "error";
      setStatus(savingToCloud ? "Speichere Eintrag in der Cloud‚Ä¶" : "Speichere Eintrag lokal‚Ä¶", tone);

      try {
        const latest = await getEntriesForWrite();
        const next = [...latest];
        const index = next.findIndex((item) => item.datum === entry.datum);
        if (index >= 0) {
          next[index] = entry;
        } else {
          next.push(entry);
        }
        next.sort(sortByDate);

        await persistEntries(next);
        form.reset();
        setDefaultDate();
      } finally {
        toggleFormDisabled(false);
      }
    }

    function handleReset() {
      form.reset();
      setDefaultDate();
    }

    function exportCsv() {
      if (!cachedEntries.length) {
        alert("Es gibt keine Eintr√§ge zum Exportieren.");
        return;
      }

      const header = [
        "Datum",
        "Stimmung",
        "Konzentration",
        "√úberreizung Vormittag",
        "√úberreizung Abend",
        "Appetit",
        "Ausbr√ºche",
        "Kopfweh",
        "Bauchweh",
        "Schwindel",
        "Auff√§lligkeiten",
      ];

      const rows = cachedEntries.map((entry) => [
        entry.datum,
        entry.stimmung,
        entry.konz,
        entry.vorm,
        entry.abend,
        entry.appetit || "",
        entry.ausbr ? "Ja" : "Nein",
        entry.kopfweh ? "Ja" : "Nein",
        entry.bauchweh ? "Ja" : "Nein",
        entry.schwindel ? "Ja" : "Nein",
        (entry.auff || "").replace(/\r?\n/g, " "),
      ]);

      const csv = [header, ...rows]
        .map((cols) =>
          cols
            .map((value) => {
              const stringValue = value.toString();
              if (/[,";]/.test(stringValue)) {
                return '"' + stringValue.replace(/\"/g, '\"\"') + '"';
              }
              return stringValue;
            })
            .join(";")
        )
        .join("\n");

      const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
      const downloadLink = document.createElement("a");
      downloadLink.href = URL.createObjectURL(blob);
      downloadLink.download = "medikinet-tagebuch_" + formatDateInput(today) + ".csv";
      downloadLink.click();
      URL.revokeObjectURL(downloadLink.href);
    }

    async function deleteEntryByDate(entryDate) {
      if (!entryDate) return;
      const confirmDelete = window.confirm(`Eintrag vom ${entryDate} l√∂schen?`);
      if (!confirmDelete) return;

      toggleFormDisabled(true);
      const deletingFromCloud = config && storageMode === "cloud";
      const tone = deletingFromCloud ? "info" : storageAvailable ? "warning" : "error";
      setStatus(
        deletingFromCloud
          ? `L√∂sche Eintrag vom ${entryDate}‚Ä¶`
          : `Entferne lokalen Eintrag vom ${entryDate}‚Ä¶`,
        tone
      );

      try {
        const latest = await getEntriesForWrite();
        const next = latest.filter((item) => item.datum !== entryDate);
        if (next.length === latest.length) {
          setStatus(`Kein Eintrag vom ${entryDate} gefunden.`, "error");
          return;
        }
        await persistEntries(next);
      } finally {
        toggleFormDisabled(false);
      }
    }

    function handleEntryAction(event) {
      const button = event.target.closest('[data-action="delete-entry"]');
      if (!button) return;
      const { entryDate } = button.dataset;
      deleteEntryByDate(entryDate);
    }

    function handleConfigSubmit(event) {
      event.preventDefault();
      const formData = new FormData(configForm);
      const next = {
        binId: formData.get("config-bin-id"),
        masterKey: formData.get("config-master-key"),
        accessKey: formData.get("config-access-key"),
      };
      const saved = applyConfig(next, { persist: storageAvailable });
      if (!saved) {
        setStatus("Bitte g√ºltige JSONBin-ID und Master-Key eingeben.", "error");
        return;
      }
      updateConfigHideAvailability();
      if (storageAvailable) {
        updateConfigSource("Konfiguration im Browser gespeichert.");
        hideConfigFormIfAllowed("Konfiguration im Browser gespeichert. Du kannst sie bei Bedarf einblenden.");
      } else {
        updateConfigSource("Konfiguration aktiv (wird nicht dauerhaft gespeichert).");
        if (configStorageNote) {
          configStorageNote.textContent =
            "Lokaler Speicher ist nicht verf√ºgbar. Die Zugangsdaten bleiben nur bis zum Schlie√üen der Seite erhalten.";
        }
        setConfigFormVisibility(true);
      }
      startDiary({ fromConfigChange: true });
    }

    function handleConfigClear() {
      clearStoredConfig();
      config = null;
      configOrigin = null;
      cachedEntries = [];
      storageMode = storageAvailable ? "local" : "memory";
      lastSyncedAt = null;
      fillConfigForm({ binId: "", masterKey: "", accessKey: "" });
      updateConfigSource("Keine JSONBin-Zugangsdaten gespeichert.");
      updateConfigHideAvailability();
      setConfigFormVisibility(true);
      startDiary({ fromConfigChange: true });
    }

    async function startDiary({ fromConfigChange = false } = {}) {
      bindDiaryEvents();
      setDefaultDate();
      syncHistoryView();

      if (!config) {
        const entries = readLocalEntries();
        cachedEntries = entries;
        renderToDom(entries);
        const message = storageAvailable
          ? "Keine JSONBin-Zugangsdaten hinterlegt. Eintr√§ge werden lokal gespeichert."
          : "Keine JSONBin-Zugangsdaten hinterlegt. Speichern ist nur tempor√§r m√∂glich.";
        setStatus(message, storageAvailable ? "warning" : "error");
        return;
      }

      toggleFormDisabled(true);
      try {
        await loadEntriesFromPreferredSource({ showStatus: true });
      } finally {
        toggleFormDisabled(false);
      }
    }

    function initializeConfigFlow() {
      setDefaultDate();
      syncHistoryView();

      if (configForm) {
        configForm.addEventListener("submit", handleConfigSubmit);
      }
      if (configClearBtn) {
        configClearBtn.addEventListener("click", handleConfigClear);
      }
      if (configRevealBtn) {
        configRevealBtn.addEventListener("click", () => {
          setConfigFormVisibility(true);
          updateConfigToggleSummary(getConfigToggleMessage());
          if (configInputs.binId) {
            configInputs.binId.focus();
          }
        });
      }
      if (configHideBtn) {
        configHideBtn.addEventListener("click", () => {
          hideConfigFormIfAllowed();
        });
      }

      updateConfigHideAvailability();

      if (configOrigin === "external" && config) {
        fillConfigForm(config);
        hideConfigFormIfAllowed("Konfiguration aus cloud-config.js geladen. Du kannst sie bei Bedarf einblenden.");
        updateConfigSource("Konfiguration aus cloud-config.js geladen.");
        startDiary();
        return;
      }

      if (configOrigin === "browser" && config) {
        fillConfigForm(config);
        hideConfigFormIfAllowed("Konfiguration aus dem Browser geladen. Du kannst sie bei Bedarf einblenden.");
        updateConfigSource("Konfiguration aus dem Browser geladen.");
        startDiary();
        return;
      }

      if (!storageAvailable && configStorageNote) {
        configStorageNote.textContent =
          "Lokaler Speicher ist nicht verf√ºgbar. Zugangsdaten bleiben nur bis zum Schlie√üen der Seite erhalten.";
      }

      fillConfigForm({ binId: "", masterKey: "", accessKey: "" });
      updateConfigSource("Noch keine Zugangsdaten gespeichert.");
      setConfigFormVisibility(true);
      startDiary();
    }

    initializeConfigFlow();
  </script>

</body>
</html>
